{% extends "dashboard/base.html" %}
{% block content %}
  <style>
    :root {
      --primary: #2ecc71;
      --secondary: #34495e;
      --bg: linear-gradient(to right, #e0f7fa, #f1f8e9);
      --white: #ffffff;
      --text: #2c3e50;
      --border: #d0d0d0;
      --accent: #16a085;
      --light-accent: #d1f2eb;
    }

    {% comment %} * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 2rem;
    } {% endcomment %}

    h2 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
      text-align: center;
      color: var(--accent);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 2rem;
      background: #ffffff;
      padding: 1rem 2rem;
      border-radius: 12px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
    }

    .controls label {
      font-size: 1rem;
      font-weight: 500;
      color: var(--secondary);
    }

    .controls input,
    .controls select {
      padding: 0.5rem 0.8rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 1rem;
      margin-left: 0.5rem;
    }

    .controls button {
      background: var(--primary);
      color: white;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.3s;
    }

    .controls button:hover {
      background: #27ae60;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: var(--white);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      margin-bottom: 2rem;
    }

    th, td {
      padding: 1rem;
      text-align: center;
      font-size: 1rem;
      border: 1px solid var(--border);
    }

    th {
      background: var(--light-accent);
      color: var(--accent);
      font-weight: bold;
    }

    td:hover {
      background: #f0fff5;
      cursor: pointer;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      z-index: 999;
    }

    .input-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ffffff;
      padding: 2rem;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      width: 300px;
    }

    .input-popup label {
      display: block;
      margin: 1rem 0 0.3rem;
      font-weight: 500;
      color: var(--secondary);
    }

    .input-popup select,
    .input-popup button {
      width: 100%;
      padding: 0.7rem;
      margin-top: 0.2rem;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 1rem;
    }

    .input-popup button {
      margin-top: 1rem;
      background: var(--primary);
      color: white;
      font-weight: 600;
      border: none;
      transition: background 0.3s;
    }

    .input-popup button:last-child {
      background: #e0e0e0;
      color: #333;
    }

    .input-popup button:hover {
      background: #27ae60;
    }

    .input-popup button:last-child:hover {
      background: #ccc;
    }
  </style>

<h2>Class Routine Manager</h2>

<!-- Global Save Button -->
<button id="globalSaveBtn" onclick="saveAllRoutines()"
  style="margin: 0 auto 1.5rem; display: block; padding: 0.7rem 1.5rem; font-size: 1rem;
         background-color: #2ecc71; color: white; border: none; border-radius: 8px; cursor: pointer;">
  üìÇ Save All Routines
</button>

<!-- Controls -->
<div class="controls">
  <label>Grade:
    <select id="gradeSelect" name="grade_id" required>
    <option value="">-- Select Grade --</option>
    {% for grade in grades %}
      <option value="{{ grade.id }}">{{ grade.grade_number }}</option>
    {% endfor %}
  </select>
  </label>
  <label>Section:
    <select id="sectionSelect" name="section_id" required>
    <option value="">-- Select Section --</option>
  </select>
  </label>
  <label>Periods:
    <input type="number" id="periodCount" min="1" max="10" value="5" />
  </label>
  <label>
    <input type="checkbox" id="autoReplicate" checked />
    Auto-replicate Sunday ‚ûû All
  </label>
  <label>
    <input type="checkbox" id="usePreviousNames" />
    Use previous column names
  </label>
  <button onclick="renderTable()">Generate Routine</button>
  <button onclick="loadRoutine()">üîÑ Load Routine</button>

</div>

<!-- Routine Display -->
<div id="tableContainer"></div>

<!-- Popup Editor -->
<div class="overlay" id="overlay" style="display: none;"></div>
<div class="input-popup" id="popup" style="display: none;">
  <label>Subject:
    <select id="subjectInput">
        <option value="">select subject</option>
    {% for subject in subjects %}
        <option value="{{ subject.id }}">{{ subject.name }}</option>
    {% endfor %}
    </select>
  </label>
  <label>Teacher:
    <select id="teacherInput">
        <option value="">select teacher</option>
    {% for teacher in teachers %}
        <option value="{{ teacher.id }}">{{ teacher.user.get_full_name }}</option>
    {% endfor %}
    </select>
  </label>
  <button onclick="saveCell()">‚úÖ Save</button>
  <button onclick="closePopup()">‚ùå Cancel</button>
</div>

<script>
const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
const tableContainer = document.getElementById('tableContainer');
let selectedCell = null;
let routineData = {};
let periodNames = {};

function getKey() {
  const grade = document.getElementById('gradeSelect').value;
  const section = document.getElementById('sectionSelect').value;
  return `${grade}-${section}`;
}

{% comment %} function checkTeacherConflict(teacher, day, period, currentKey) {
  for (const key in routineData) {
    if (key !== currentKey) {
      const dayData = routineData[key]?.[day];
      if (dayData?.[period]?.teacher === teacher) return true;
    }
  }
  return false;
} {% endcomment %}
 function checkTeacherConflict(teacherId, day, period, currentKey) {
  for (const key in routineData) {
    if (key !== currentKey) {
      const entry = routineData[key]?.[day]?.[period];
      if (entry && entry.teacher_id === teacherId) {
        return true;
      }
    }
  }
  return false;
}


function renderTable() {
  const grade = document.getElementById('gradeSelect').value;
  const sectionSelect = document.getElementById('sectionSelect');
  const section = sectionSelect.value;

  // Allow if grade is selected and either:
  // - sectionSelect is disabled
  // - sectionSelect has no options (e.g., no sections exist for that grade)
  // - or section is selected
  if (!grade || (sectionSelect && !section && !sectionSelect.disabled && sectionSelect.options.length > 1)) {
    alert('‚ö†Ô∏è Please select both Grade and Section before generating the routine.');
    return;
  }


  const count = parseInt(document.getElementById('periodCount').value);
  const key = getKey();
  const usePrev = document.getElementById('usePreviousNames')?.checked;

  if (!routineData[key]) routineData[key] = {};

  if (!periodNames[key]) {
    if (usePrev && Object.keys(periodNames).length > 0) {
      const lastKey = Object.keys(periodNames).reverse().find(k => k !== key);
      periodNames[key] = lastKey ? [...periodNames[lastKey]] : [];
    } else {
      periodNames[key] = [];
    }
  }

  for (let i = 0; i < count; i++) {
    if (!periodNames[key][i]) {
      periodNames[key][i] = `Period ${i + 1}`;
    }
  }

  const currentData = routineData[key];
  const existing = document.getElementById(`routine-${key}`);
  if (existing) existing.remove();

  const wrapper = document.createElement('div');
  wrapper.id = `routine-${key}`;
  wrapper.style.marginBottom = '3rem';

  const headerDiv = document.createElement('div');
  headerDiv.style.display = 'flex';
  headerDiv.style.justifyContent = 'space-between';
  headerDiv.style.alignItems = 'center';
  headerDiv.style.margin = '1rem 0';
  headerDiv.innerHTML = `<h3 style="margin: 0;">Routine: Grade ${key}</h3>`;

  const resetBtn = document.createElement('button');
  resetBtn.textContent = 'Reset Routine';
  resetBtn.style.cssText = 'background: #e74c3c; color: white; padding: 0.4rem 0.8rem; border: none; border-radius: 6px; cursor: pointer;';
  resetBtn.onclick = () => {
    if (confirm('Are you sure you want to reset this routine?')) {
      delete routineData[key];
      renderTable();
    }
  };

  headerDiv.appendChild(resetBtn);
  wrapper.appendChild(headerDiv);

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const headRow = document.createElement('tr');

  const firstCol = document.createElement('th');
  firstCol.textContent = 'Day \\ Period';
  headRow.appendChild(firstCol);

  for (let i = 0; i < count; i++) {
    const th = document.createElement('th');
    th.contentEditable = true;
    th.textContent = periodNames[key][i];
    th.dataset.index = i;
    th.addEventListener('blur', () => {
      periodNames[key][i] = th.textContent.trim() || `Period ${i + 1}`;
    });
    th.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        th.blur();
      }
    });
    headRow.appendChild(th);
  }

  thead.appendChild(headRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  days.forEach(day => {
    const tr = document.createElement('tr');
    const rowLabel = document.createElement('td');
    rowLabel.innerHTML = `<strong>${day}</strong>`;
    tr.appendChild(rowLabel);

    let p = 1;
    while (p <= count) {
      const entry = currentData[day]?.[p];
      let span = 1;
      while (
        p + span <= count &&
        currentData[day]?.[p + span] &&
        currentData[day][p + span].subject === entry?.subject &&
        currentData[day][p + span].teacher === entry?.teacher
      ) {
        span++;
      }

      const td = document.createElement('td');
      td.colSpan = span;
      td.innerHTML = (entry && entry.subject && entry.teacher)
        ? `<div style="position:relative;"><div style="position:absolute;top:4px;right:6px;font-weight:bold;color:#e74c3c;cursor:pointer;" onclick='resetCell(event, "${day}", ${p}, ${span}, "${key}")'>√ó</div><div>${entry.subject}</div><div style="font-size: 0.9em; color: #555;">(${entry.teacher})</div></div>`
        : '';
      td.onclick = () => openPopup(td, span, currentData);
      td.dataset.day = day;
      td.dataset.period = p;
      td.dataset.key = key;
      td.dataset.colspan = span;

      tr.appendChild(td);
      p += span;
    }

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  wrapper.appendChild(table);
  tableContainer.appendChild(wrapper);
}

function resetCell(event, day, periodStart, span, key) {
  event.stopPropagation();
  for (let i = 0; i < span; i++) {
    if (routineData[key] && routineData[key][day]) {
      delete routineData[key][day][periodStart + i];
    }
  }
  renderTable();
}


{% comment %} function openPopup(cell, colspan = 1, currentData) {
  selectedCell = { cell, colspan, currentData };
  const content = cell.innerText.trim().split('\n');
  const subject = content[0] || '';
  const teacher = content[1] ? content[1].replace(/[()]/g, '') : '';

  document.getElementById('subjectInput').value = subject;
  document.getElementById('teacherInput').value = teacher;
  document.getElementById('overlay').style.display = 'block';
  document.getElementById('popup').style.display = 'block';
} {% endcomment %}

function openPopup(cell, colspan = 1, currentData) {
  selectedCell = { cell, colspan, currentData };

  const day = cell.dataset.day;
  const period = parseInt(cell.dataset.period);
  const key = cell.dataset.key;

  const teacherSelect = document.getElementById('teacherInput');
  const allOptions = Array.from(teacherSelect.options);

  // Reset all first
  allOptions.forEach(opt => {
    opt.disabled = false;
    opt.textContent = opt.textContent.replace(' (busy)', '');
  });

  // Disable if same teacher is already booked in another section
  for (const k in routineData) {
    if (k === key) continue;

    const teacherEntry = routineData[k]?.[day]?.[period];
    if (teacherEntry?.teacher_id) {
      const match = allOptions.find(opt => opt.value === teacherEntry.teacher_id);
      if (match) {
        match.disabled = true;
        match.textContent += ' (busy)';
      }
    }
  }

  // Pre-fill subject/teacher if editing
  const content = cell.innerText.trim().split('\n');
  const subject = content[0] || '';
  const teacher = content[1] ? content[1].replace(/[()]/g, '') : '';

  document.getElementById('subjectInput').value = subject;
  teacherSelect.value = teacher;

  document.getElementById('overlay').style.display = 'block';
  document.getElementById('popup').style.display = 'block';
}



function closePopup() {
  selectedCell = null;
  document.getElementById('overlay').style.display = 'none';
  document.getElementById('popup').style.display = 'none';
}

{% comment %} function saveCell() {
  const subject = document.getElementById('subjectInput').value;
  const teacher = document.getElementById('teacherInput').value;
  const { cell, colspan, currentData } = selectedCell;
  const day = cell.dataset.day;
  const periodStart = parseInt(cell.dataset.period);
  const key = cell.dataset.key;

  for (let i = 0; i < colspan; i++) {
    if (checkTeacherConflict(teacher, day, periodStart + i, key)) {
      alert(`‚ùå Teacher ${teacher} is already assigned at Period ${periodStart + i} on ${day} in another class.`);
      return;
    }
  }

  if (!routineData[key]) routineData[key] = {};
  if (!routineData[key][day]) routineData[key][day] = {};

  for (let i = 0; i < colspan; i++) {
    routineData[key][day][periodStart + i] = { subject, teacher };
  }

  const replicate = document.getElementById('autoReplicate')?.checked ?? true;
  if (replicate && day === 'Sunday') {
    days.forEach(d => {
      if (d === 'Sunday') return;
      if (!routineData[key][d]) routineData[key][d] = {};
      for (let i = 0; i < colspan; i++) {
        if (!checkTeacherConflict(teacher, d, periodStart + i, key)) {
          routineData[key][d][periodStart + i] = { subject, teacher };
        }
      }
    });
  }

  closePopup();
  renderTable();
} {% endcomment %}

function saveCell() {
  const subjectSelect = document.getElementById('subjectInput');
  const teacherSelect = document.getElementById('teacherInput');

  const subjectId = subjectSelect.value;
  const subjectName = subjectSelect.options[subjectSelect.selectedIndex].text;

  const teacherId = teacherSelect.value;
  const teacherName = teacherSelect.options[teacherSelect.selectedIndex].text;

  const { cell, colspan, currentData } = selectedCell;
  const day = cell.dataset.day;
  const periodStart = parseInt(cell.dataset.period);
  const key = cell.dataset.key;

  for (let i = 0; i < colspan; i++) {
    if (checkTeacherConflict(teacherId, day, periodStart + i, key)) {
      alert(`‚ùå Teacher ${teacherName} is already assigned at Period ${periodStart + i} on ${day} in another class.`);
      return;
    }
  }

  if (!routineData[key]) routineData[key] = {};
  if (!routineData[key][day]) routineData[key][day] = {};

  for (let i = 0; i < colspan; i++) {
    routineData[key][day][periodStart + i] = {
      subject_id: subjectId,
      subject: subjectName,
      teacher_id: teacherId,
      teacher: teacherName
    };
  }

  const replicate = document.getElementById('autoReplicate')?.checked ?? true;
  if (replicate && day === 'Sunday') {
    days.forEach(d => {
      if (d === 'Sunday') return;
      if (!routineData[key][d]) routineData[key][d] = {};
      for (let i = 0; i < colspan; i++) {
        if (!checkTeacherConflict(teacherId, d, periodStart + i, key)) {
          routineData[key][d][periodStart + i] = {
            subject_id: subjectId,
            subject: subjectName,
            teacher_id: teacherId,
            teacher: teacherName
          };
        }
      }
    });
  }

  closePopup();
  renderTable();
}


{% comment %} function saveAllRoutines() {
  console.log('üìò All routines:', routineData);
  alert('‚úÖ All routines saved!');
} {% endcomment %}
{% comment %} function saveAllRoutines() {
  const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
  const data = {
    routines: routineData,
    period_names: periodNames
  };

  fetch('{% url 'save_routine' %}', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': csrfToken
    },
    body: JSON.stringify(data)
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      alert('‚úÖ All routines saved successfully!');
    } else {
      alert('‚ùå Error saving routines: ' + data.error);
    }
  })
  .catch(error => {
    console.error('Error:', error);
    alert('‚ùå Failed to save routines');
  });
} {% endcomment %}
function saveAllRoutines() {
  // More reliable way to get CSRF token
  const csrfToken = getCSRFToken();
  
  if (!csrfToken) {
    alert('‚ùå CSRF token missing. Please refresh the page and try again.');
    return;
  }

  const data = {
    routines: routineData,
    period_names: periodNames
  };

  console.log("routine data", routineData);
  console.log("period names", periodNames);

  fetch('{% url 'save_routine' %}', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': csrfToken
    },
    body: JSON.stringify(data)
  })
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    if (data.success) {
      alert('‚úÖ All routines saved successfully!');
      // Optional: Clear any unsaved changes indication
    } else {
      alert('‚ùå Error saving routines: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(error => {
    console.error('Error:', error);
    alert('‚ùå Failed to save routines. Check console for details.');
  });
}

// Helper function to get CSRF token
function getCSRFToken() {
  // Try different ways to get the CSRF token
  const cookieValue = document.cookie
    .split('; ')
    .find(row => row.startsWith('csrftoken='))
    ?.split('=')[1];
  
  const formToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
  const metaToken = document.querySelector('meta[name=csrf-token]')?.content;
  
  return cookieValue || formToken || metaToken;
}


  // Get the sections data from Django context
  const sectionsByGrade = {{ sections_by_grade|safe }};

  const gradeSelect = document.getElementById("gradeSelect");
  const sectionSelect = document.getElementById("sectionSelect");

  gradeSelect.addEventListener("change", function () {
    const gradeId = this.value;

    // Clear existing options
    sectionSelect.innerHTML = '<option value="">-- Select Section --</option>';

    if (sectionsByGrade[gradeId]) {
      sectionsByGrade[gradeId].forEach(section => {
        const option = document.createElement("option");
        option.value = section.id;
        option.textContent = section.name;
        sectionSelect.appendChild(option);
      });
    }
  }); 
  {% comment %} gradeSelect.addEventListener("change", function () {
  const gradeId = this.value;

  // Clear section dropdown
  sectionSelect.innerHTML = '<option value="">-- Select Section --</option>';

  // üßπ Clear routine display
  tableContainer.innerHTML = '';

  // üßπ Remove old routine data (unrelated sections)
  for (const key in routineData) {
    if (!key.startsWith(`${gradeId}-`)) {
      delete routineData[key];
    }
  }

  // üßπ Remove old period names
  for (const key in periodNames) {
    if (!key.startsWith(`${gradeId}-`)) {
      delete periodNames[key];
    }
  }

  // ‚úÖ Load new section options for this grade
  if (sectionsByGrade[gradeId]) {
    sectionsByGrade[gradeId].forEach(section => {
      const option = document.createElement("option");
      option.value = section.id;
      option.textContent = section.name;
      sectionSelect.appendChild(option);
    });
  }
}); {% endcomment %}



function loadRoutine() {
  const gradeId = document.getElementById("gradeSelect").value;
  const sectionId = document.getElementById("sectionSelect").value;

  if (!gradeId || !sectionId) {
    alert("‚ö†Ô∏è Please select both Grade and Section first.");
    return;
  }

  const key = `${gradeId}-${sectionId}`;

  fetch(`/load_routine/?grade=${gradeId}&section=${sectionId}`)
    .then(res => res.json())
    .then(data => {
      if (data.routine && data.routine[key]) {
        //routineData[key] = data.routine[key];
        routineData = data.routine; // merge all sections

        //alert("‚úÖ Routine loaded successfully.");
      } else {
        routineData[key] = {};
        alert("‚ÑπÔ∏è No saved routine found. You can generate a new one.");
      }

      periodNames[key] = periodNames[key] || [];  // safe fallback
      renderTable();
    })
    .catch(err => {
      console.error("‚ùå Failed to load routine", err);
      alert("‚ùå Error loading routine. Check console.");
    });
} 




</script>
{% endblock %}